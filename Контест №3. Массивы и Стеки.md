# Контест №3. Массивы и Стеки.

## <ins>**Темы для решения контеста №3:**<ins/>

>• Динамический массив: [SimpleCode - урок "Динамический массив"](https://youtu.be/fk4YTLsnKmw);
>
>• Динамический массив (Vector): [Канал какого-то студента - урок "Вектор"](https://youtu.be/QOik-wo_uQE);
>
>• Функции и стеки: [SimpleCode - урок "Стеки"](https://youtu.be/jUJngLO_c_0);
>
>• Set и MultiSet: [SimpleCode - урок: "SET | MULTISET](https://youtu.be/i02_JDJS3yw);
>
>• Map и MultiMap: [SimpleCode - урок: "MAP | MULTIMAP](https://youtu.be/QKrJRE-GnYU)

# C++

**1. Объединить отсортированные последовательности.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <vector> // Подключаем библиотеку для работы с динамическими массивами (std::vector).
using namespace std; // Используем пространства имён.

int main() { // Объявляем главную функцию программы, с которой начинается выполнение.
    int n, m; // Объявлем переменные n и m. Хранят размеры двух массивов.
    vector<int> nums; // Объявляем вектор для хранения результата (объединённого массива). Сюда мы будем складывать результат — объединённый отсортированный массив.
    cin >> n; // Программа ждёт ввода числа n (размер первого массива). 
    vector<int> N(n); // Объявляем вектор N размером n.
    for (int i = 0; i<n; i++) { // Цикл, который заполняет вектор N числами, введёнными с клавиатуры. i - счетчик.
        cin >> N[i]; // На каждой итерации ждём ввода числа и кладём его в N[i] (элемент вектора с индексом i).
    }
    cin >> m; // Программа ждёт ввода числа m (размер второго массива).
    vector<int> M(m); // Создаём вектор M размером m (как в строке 8).
    for (int i = 0; i<m; i++) { // Цикл, который заполняет вектор M числами, введёнными с клавиатуры. i - счетчик.
        cin >> M[i]; // На каждой итерации ждём ввода числа и кладём его в M[i] (элемент вектора с индексом i).
    }
    int i = 0, j = 0; // Создаём два счётчика: i и j. i будет «ходить» по вектору N. j будет «ходить» по вектору M. Оба начинаются с первого элемента.
    while (i<n && j<m) { // Цикл работает, пока i не вышел за границы N и j не вышел за границы M.
        if (N[i]<M[j]) { // Сравниваем текущие элементы: Если N[i] меньше M[j], то:
            nums.push_back(N[i]); // Добавляем N[i] в конец вектора nums.
            i++; // Сдвигаем указатель i на следующий элемент N.
        } else { // Иначе (если M[j] меньше или равно N[i]):
            nums.push_back(M[j]); // Добавляем M[j] в конец nums.
            j++; // Сдвигаем указатель j на следующий элемент M.
        }
    }
    while (i<n) nums.push_back(N[i++]); // Если после основного цикла в N остались элементы (т. е. i < n), добавляем их все в nums. i++ - «взять N[i], добавить в nums, потом увеличить i на 1». Поскольку N и M были отсортированы, оставшиеся элементы гарантированно больше всех уже добавленных.
    
    while (j<m) nums.push_back(M[j++]); // Если после основного цикла в M остались элементы (т. е. i < m), добавляем их все в nums. i++ - «взять M[i], добавить в nums, потом увеличить i на 1». Поскольку N и M были отсортированы, оставшиеся элементы гарантированно больше всех уже добавленных.
    
    for (int num : nums) cout << num << " "; // Это цикл по всем элементам вектора nums. В итоге все числа из nums выводятся в одну строку через пробелы.
}
```

**2. Валидатор скобочной последовательности.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <stack> // Подключает библиотеку, которая реализует структуру данных «стек» (stack).
using namespace std; // Используем пространства имён.

int main() { // Объявляем главную функцию программы, с которой начинается выполнение.
    stack<char> st; // Создаём стек st, который будет хранить символы (char). В этот стек мы будем складывать открывающие скобки.
    string str; // Создаём строку str, в которую будем считывать ввод пользователя.
    getline(cin, str, '!'); // Считывает строку из входного потока (cin, т. е. с клавиатуры) в переменную str. Cчитываем до символа ! (включая его).
    for (char c : str) { // Начинаем цикл, который переберёт каждый символ c из строки str. На каждой итерации c будет очередным символом строки (сначала первый, потом второй и т. д.).
        if (c == '(' || c == '{' || c == '[') { // Проверяем, является ли текущий символ c открывающей скобкой: ( или { или [. Если да, то добавляет этот символ в стек st с помощью метода push(). Например, если c — это (, то в стек кладётся (.
        
            st.push(c); // Проверяем, что стек не пуст (!st.empty() означает «не пусто»).
        }
        if (c == ')' || c == '}' || c == ']') { // Проверяем, является ли текущий символ c закрывающей скобкой: ) или } или ].
            if (!st.empty()) { // Проверяет, что стек не пуст (!st.empty() означает «не пусто»). Если стек пуст, а мы встретили закрывающую скобку — это ошибка (нет соответствующей открывающей скобки).
                if (st.top() == '(' && c == ')'|| st.top() == '{' && c == '}'|| st.top() == '[' && c == ']') { // st.top() — получает верхний (последний добавленный) элемент стека.
                                                                                                               // Проверяем, соответствует ли открывающая скобка в стеке текущей закрывающей скобке:
                                                                                                               // Если в стеке (, а текущая скобка ), то всё ок.
                                                                                                               // Если в стеке {, а текущая }, то ок.
                                                                                                               // Если в стеке [, а текущая ], то ок.
                
                    st.pop(); // Если соответствие есть, то удаляем верхний элемент из стека с помощью st.pop() (т. е. «закрываем» пару скобок).
                } else { // Если скобки не соответствуют (например, в стеке (, а текущая скобка }), то:
                    cout << "NO"; // Выводим "NO" (скобки расставлены неправильно).
                    return 0; // Завершаем программу с помощью return 0 (возвращаем код успеха, но программа уже сообщила об ошибке).
                }
            } else { // Если стек пуст, а мы встретили закрывающую скобку, значит, нет открывающей скобки для неё.
                cout << "NO"; // Выводим "NO".
                return 0; // Завершаем программу.
            }
        }
    }
    // После обработки всех символов проверяем, пуст ли стек:
    if (st.empty()) {  // Если стек пуст (st.empty()), значит, все открывающие скобки были «закрыты» соответствующими закрывающими.
        cout << "YES"; // Выводим "YES" (скобки расставлены правильно).
    } else { // Если стек не пуст, значит, остались незакрытые открывающие скобки.
        cout << "NO"; // Выводим "NO" (ошибка).
    }
}
```

**4. Общие слова в последовательностях.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <set> // Подключаем библиотеку <set> — она реализует структуру данных «множество» (set), где хранятся уникальные элементы в отсортированном порядке.
using namespace std; // Используем пространства имён.

int main() { // Объявляем главную функцию программы, с которой начинается выполнение.
    int n, m; // Объявляем две целочисленные переменные: n и m. Они будут хранить количество элементов в двух наборах.
    string sn, sm; // Объявляем две строковые переменные: sn и sm. В них будут храниться строки, содержащие элементы первого и второго наборов соответственно.
    set<string> N, M; // Создаём два множества (set) строк: N и M. В них мы будем помещать уникальные 5‑символьные подстроки из sn и sm.
    cin >> n; // Считываем целое число n с клавиатуры. Количество элементов в первом наборе.
    cin.ignore(); // Пропускаем один символ из входного потока (обычно это символ перевода строки \n, оставшийся после ввода n). Это нужно, чтобы следующий getline не считал пустую строку.
    getline(cin, sn); // Считываем всю строку целиком в переменную sn.

    // Разбиение строки sn на 5‑символьные элементы и добавление в множество.
    for (size_t i = 0; i < sn.length(); i += 6) { // Цикл for перебирает строку sn с шагом 6 (5 символов элемента + 1 пробел). 
                                                  // size_t i = 0 — начальная позиция в строке (индекс 0).
                                                  // i < sn.length() — условие продолжения цикла: пока индекс i не вышел за пределы. 
                                                  // i += 6 — увеличиваем i на 6 после каждой итерации (чтобы перейти к следующему элементу).
    
        N.insert(sn.substr(i, 5)); // N.insert(...) — добавляет извлечённую подстроку в множество N. Если элемент уже есть в N, он не дублируется (свойство set). 
                                   // sn.substr(i, 5) — извлекает подстроку длиной 5 символов, начиная с позиции i.
        
    }
    cin >> m; // Считываем целое число m с клавиатуры. Количество элементов в первом наборе.
    cin.ignore(); // Пропускаем один символ из входного потока.
    getline(cin, sm); // Считываем всю строку целиком в переменную sm.

    // Разбиение строки sm на 5‑символьные элементы и добавление в множество 
    for (size_t i = 0; i < sm.length(); i += 6) { // Цикл for перебирает строку sm с шагом 6 (5 символов элемента + 1 пробел). 
                                                  // size_t i = 0 — начальная позиция в строке (индекс 0).
                                                  // i < sm.length() — условие продолжения цикла: пока индекс i не вышел за пределы.
                                                  // i += 6 — увеличиваем i на 6 после каждой итерации (чтобы перейти к следующему элементу).
    
        M.insert(sm.substr(i, 5)); // M.insert(...) — добавляет извлечённую подстроку в множество M. Если элемент уже есть в M, он не дублируется (свойство set).
                                   // sm.substr(i, 5) — извлекает подстроку длиной 5 символов, начиная с позиции i.
        
    }
    int k = 0; // Объявляем переменную k, которая будет считать количество найденных общих элементов.
    for (string s : N) { // Перебираем все элементы множества N (каждый элемент — строка s).
        if (M.count(s) > 0) { // Проверяем, есть ли элемент s в множестве M. M.count(s) возвращает 1, если s есть в M, и 0, если нет.
            if (k!=0) { // Если k != 0 (т.е. уже был выведен хотя бы один элемент): ...
                cout << ' '; // ... Добавляем пробел перед следующим элементом. Это нужно, чтобы элементы выводились через пробел, а не слитно.
            }
            cout << s; // Выводим текущий элемент s (он есть и в N, и в M).
            k++; // Увеличиваем счётчик k на 1 (нашли ещё один общий элемент).
        }
    }
    if (k == 0) cout << -1; // Если k == 0 (не было найдено ни одного общего элемента), выводим -1.
}
```

**5. Самое частое слово.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <map> // Подключает библиотеку, которая реализует структуру данных «словарь» (map) — ассоциативный контейнер, где каждому ключу соответствует значение. Нам понадобится для подсчёта количества вхождений подстрок.

using namespace std; // Используем пространства имён. 

int main() { // Объявляем главную функцию программы, с которой начинается выполнение.
    int n; // Объявляем целочисленную переменную n. В неё будет записано число, которое пользователь введёт первым.
    string sn; // Объявляем строковую переменную sn. В неё будет записана строка, которую пользователь введёт вторым шагом.
    map<string, int> N; // Создаёт словарь (map), где: ключ — строка (string), значение — целое число (int). Этот словарь будет использоваться для подсчёта, сколько раз каждая подстрока длиной 5 символов встречается в строке sn.
    
    cin >> n; // Читаем целое число с клавиатуры и сохраняет его в переменную n.
    cin.ignore(); // Пропускаем один символ из входного потока (обычно это символ перевода строки \n, оставшийся после ввода числа). Нужно, чтобы следующий вызов getline не «захватил» этот символ.
    getline(cin, sn); // Читаем целую строку (включая пробелы) с клавиатуры и сохраняет её в переменную sn.

    // Первый цикл: разбиение строки на подстроки и подсчёт их вхождений.
    for (size_t i = 0; i < sn.length(); i += 6) { // Начинаем цикл, который будет проходить по строке sn с шагом 6 символов. 
                                                  // size_t — беззнаковый целочисленный тип для индексов.
                                                  // i — счётчик цикла, начинается с 0.
                                                  // Цикл продолжается, пока i меньше длины строки sn.
                                                  // На каждой итерации i увеличивается на 6.
    
        N[sn.substr(i, 5)]++; // sn.substr(i, 5) — извлекает подстроку из sn длиной 5 символов, начиная с позиции i.
        // N[подстрока] — обращается к элементу словаря N с ключом‑подстрокой. Если такой ключ ещё не существует, он создаётся со значением 0.
        // ++ увеличивает значение на 1. Таким образом, для каждой подстроки длиной 5 символов мы увеличиваем счётчик её вхождений в словаре N.

    }
    int max = 0; // Объявляем переменную max для хранения максимального количества вхождений какой‑либо подстроки
    for (auto i : N) { // Перебирает все элементы словаря N.
                       // auto автоматически определяет тип переменной i (это пара ключ‑значение). 
                       // На каждой итерации i содержит один элемент словаря.
                       
        int count = i.second; // Извлекаем значение (количество вхождений) из текущего элемента словаря. 
                              // i.second — это число, соответствующее ключу i.first.
                              
        if (count > max) { // Проверяем, больше ли текущее количество вхождений (count), чем сохранённое максимальное (max).
            max = count; // Если условие истинно, обновляет max до текущего значения count.
        }
    }
    int k = 0; // Объявляем счётчик k для отслеживания, сколько подстрок уже было выведено. Нужен, чтобы правильно расставить пробелы между выводами.
    for (auto i : N) { // Снова перебираем все элементы словаря N.
        int count = i.second; // Получаем количество вхождений текущей подстроки.
        if (count == max) { // Проверяем, равно ли количество вхождений текущему максимуму (max).
            if (k > 0) cout << " "; // Если уже были выведены какие‑то подстроки (k > 0), добавляет пробел перед следующей. Это нужно, чтобы подстроки разделялись пробелами, а не слипались.
            cout << i.first; // Выводим ключ (подстроку) текущего элемента словаря.
            k++; // Увеличиваем счётчик выведенных подстрок на 1.
        }
    }
}
```

**6. Баланс пользователя.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <map> // Подключает библиотеку, которая реализует структуру данных «словарь» (map) — ассоциативный контейнер, где каждому ключу соответствует значение. Нам понадобится для подсчёта количества вхождений 
using namespace std; // Используем пространства имён.

int main() { // Объявляем главную функцию программы, с которой начинается выполнение.
    int n, m; // Создаём две целочисленные переменные: n и m. 
              // n будет хранить количество записей в словаре. 
              // m — количество слов для поиска.
              
    map<string, string> N; // Создаём словарь (map) с именем N, где и ключ, и значение — строки (string). В этот словарь мы будем складывать пары «слово → его перевод/значение».
    cin >> n; // Считываем число n с клавиатуры (сколько пар «ключ‑значение» будет введено).
    cin.ignore(); // Пропускаем один символ (обычно это символ перевода строки \n после ввода числа).
    for (int i = 0; i < n; i++) { // Запускаем цикл, который повторится n раз (по числу записей в словаре). i — счётчик, начинается с 0, цикл продолжается, пока i < n.
        string key, value; // Внутри цикла создаём две строки: key (ключ) и value (значение). Для каждой записи в словаре нужно прочитать ключ и значение.
        getline(cin, key, ';'); // Читаем строку до символа ; и сохраняет её в key. Разделитель ; помогает отделить ключ от значения.
        cin >> value; // Читаем следующее слово (до пробела или перевода строки) и сохраняет в value.
        cin.ignore(); // Снова пропускаем символ перевода строки (\n), чтобы не мешать следующему чтению.
        N[key] = value; // Добавляем в словарь N пару «ключ‑значение»: key → value.
    }
    cin >> m; // Считываем число m — сколько слов мы хотим перевести/найти в словаре.
    for (int i = 0; i < m; i++) { // Запускаем цикл, который повторится m раз (по числу слов для поиска). i — счётчик, начинается с 0, цикл продолжается, пока i < m.
        string word; // Создаём строку word для хранения очередного слова для поиска.
        cin >> word; // Считываем слово с клавиатуры и сохраняет в word.
        if (i > 0) { // Если это не первое слово (i > 0) ...
            cout << ' '; // ... Выводим пробел перед следующим словом. Чтобы результаты выводились через пробел (а не слитно).
        }
        cout << N[word]; // Выводим значение из словаря N для ключа word. Если слова нет в словаре, программа может вести себя непредсказуемо (в C++ доступ к несуществующему ключу создаёт его с пустым значением).
    }
}
``` 

# Golang

**8. Уникальное число.**
```go
package main // Строка начала исполняемой программы.
import "fmt" // Подключаем библиотеку для форматированного вывода (например, fmt.Println).

func main() { // Объявляем главную функцию программы, с которой начинается выполнение. 
    var n, num int // Объявляем две переменные одного типа. 
                   // n — будет хранить количество чисел, которые мы прочитаем.
                   // num — будет временно хранить каждое введённое число.
                   
    numbers := map[int]bool{} // Создаём карту (map) — структуру данных «ключ‑значение». map[int]bool означает:
                              // Ключи — целые числа (int),
                              // Значения — булевы (bool: true или false).
    
    fmt.Scan(&n) // Читаем одно целое число с ввода и сохраняем его в переменную n. 
                 // &n — передача адреса переменной n (чтобы Scan мог записать туда значение). 
                 // n будет количеством чисел, которые мы дальше прочитаем.
    
    for i := 0; i < n; i++ { // Начинаем цикл for:
                             // i := 0 — инициализация счётчика (начинаем с 0),
                             // i < n — условие: цикл работает, пока i меньше n,
                             // i++ — увеличение i на 1 после каждой итерации.
    
        fmt.Scan(&num) // Читаем одно число и сохраняем его в num. Каждое прочитанное число будет обрабатываться в теле цикла.
        numbers[num] = !numbers[num] // Получаем значение по ключу num из карты. Если ключа ещё нет, Go автоматически возвращает нулевое значение типа (false для bool).
                                     // !numbers[num] — инвертируем значение: Если было false → станет true, если было true → станет false.

    }
    for i, value := range numbers { // Начинаем цикл по карте numbers:
                                    // range numbers — перебирает все пары «ключ‑значение» в карте.
                                    // i — переменная для ключа (число из ввода),
                                    // value — переменная для значения (true или false).
    
        if value { // Проверяем, равно ли value true. Если да — значит, число i встретилось нечётное количество раз.
            fmt.Print(i) // Печатаем число i (ключ карты), если его значение true.
        }
    }
}
```
