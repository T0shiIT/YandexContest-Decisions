# Контест №3. Массивы и Стеки.

## <ins>**Темы для решения контеста №3:**<ins/>

>• Динамический массив: [SimpleCode - урок "Динамический массив"](https://youtu.be/fk4YTLsnKmw);
>
>• Динамический массив (Vector): [Канал какого-то студента - урок "Вектор"](https://youtu.be/QOik-wo_uQE);
>
>• Функции и стеки: [SimpleCode - урок "Стеки"](https://youtu.be/jUJngLO_c_0)

# C++

**1. Объединить отсортированные последовательности.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <vector> // Подключаем библиотеку для работы с динамическими массивами (std::vector).
using namespace std; // Используем пространства имён.

int main() { // Объявляем главную функцию программы, с которой начинается выполнение.
    int n, m; // Объявлем переменные n и m. Хранят размеры двух массивов.
    vector<int> nums; // Объявляем вектор для хранения результата (объединённого массива). Сюда мы будем складывать результат — объединённый отсортированный массив.
    cin >> n; // Программа ждёт ввода числа n (размер первого массива). 
    vector<int> N(n); // Объявляем вектор N размером n.
    for (int i = 0; i<n; i++) { // Цикл, который заполняет вектор N числами, введёнными с клавиатуры. i - счетчик.
        cin >> N[i]; // На каждой итерации ждём ввода числа и кладём его в N[i] (элемент вектора с индексом i).
    }
    cin >> m; // Программа ждёт ввода числа m (размер второго массива).
    vector<int> M(m); // Создаём вектор M размером m (как в строке 8).
    for (int i = 0; i<m; i++) { // Цикл, который заполняет вектор M числами, введёнными с клавиатуры. i - счетчик.
        cin >> M[i]; // На каждой итерации ждём ввода числа и кладём его в M[i] (элемент вектора с индексом i).
    }
    int i = 0, j = 0; // Создаём два счётчика: i и j. i будет «ходить» по вектору N. j будет «ходить» по вектору M. Оба начинаются с первого элемента.
    while (i<n && j<m) { // Цикл работает, пока i не вышел за границы N и j не вышел за границы M.
        if (N[i]<M[j]) { // Сравниваем текущие элементы: Если N[i] меньше M[j], то:
            nums.push_back(N[i]); // Добавляем N[i] в конец вектора nums.
            i++; // Сдвигаем указатель i на следующий элемент N.
        } else { // Иначе (если M[j] меньше или равно N[i]):
            nums.push_back(M[j]); // Добавляем M[j] в конец nums.
            j++; // Сдвигаем указатель j на следующий элемент M.
        }
    }
    while (i<n) nums.push_back(N[i++]); // Если после основного цикла в N остались элементы (т. е. i < n), добавляем их все в nums. i++ - «взять N[i], добавить в nums, потом увеличить i на 1». Поскольку N и M были отсортированы, оставшиеся элементы гарантированно больше всех уже добавленных.
    
    while (j<m) nums.push_back(M[j++]); // Если после основного цикла в M остались элементы (т. е. i < m), добавляем их все в nums. i++ - «взять M[i], добавить в nums, потом увеличить i на 1». Поскольку N и M были отсортированы, оставшиеся элементы гарантированно больше всех уже добавленных.
    
    for (int num : nums) cout << num << " "; // Это цикл по всем элементам вектора nums. В итоге все числа из nums выводятся в одну строку через пробелы.
}
```
