# Контест №2. Функции и Массивы

## <ins>**Темы для решения контеста №2:**<ins/>

>• Фукнции: [SimpleCode - урок "Функции".](https://youtu.be/HFH65-sNQmI);

>• Динамический массив: [SimpleCode - урок "Динамический массив"](https://youtu.be/fk4YTLsnKmw);

**1. Функция. Простое число**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.

bool is_prime(int n) { // Объявляем функцию is_prime, которая проверяет, является ли число простым.
    if (n < 2) return false; // Проверяем, меньше ли число 2. 
    if (n == 2) return true; // Проверяем, равно ли число 2.
    if (n % 2 == 0) return false; // Проверяем, делится ли число на 2 без остатка.
    
    for (int i = 3; i <= n / i; i += 2) { // Запускаем цикл для проверки делителей числа n.
        if (n % i == 0) return false; // Проверяем, делится ли n на текущий делитель i без остатка.
    }
    return true; // Возвращаем true, если цикл завершился без нахождения делителей.
}

int main(){ // Объявляем главную функцию программы, с которой начинается выполнение.
    int number; // Объявляем переменную number типа int для хранения введённого числа.
    std::cin >> number; // Считываем целое число и сохраняем его в переменную number.
    std::cout << (is_prime(number) ? "YES" : "NO") << std::endl;  // Выводим результат проверки числа, простое ли оно.
}
```

**2. Функция. Выход из лабиринта**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <vector> // Подключаем библиотеку для работы с динамическими массивами (std::vector).
#include <string> // Подключаем библиотеку для работы со строками (std::string).

bool is_can_exit_from_maze(std::vector<std::string>& maze, int row, int col) // Объявляем рекурсивную функцию, проверяющую, можно ли выйти из лабиринта из заданной точки.
{                                                 // maze - ссылка на вектор строк, представляющий лабиринт.
                                                  // row - текущая строка (координата Y) и col — текущий столбец (координата X).
    if (maze[row][col] =='#' || maze[row][col] =='.') return false; // Проверяем, является ли текущая клетка стеной ('#') или уже пройденной ('.'). Если да - возвращаем false (дальше идти нельзя).
    if (maze[row][col] == 'E') return true; // Если текущая клетка - выход ('E'), возвращаем true (цель достигнута).
    
    maze[row][col]='.'; // Помечаем текущую клетку как пройденную (заменяем символ на '.'), дабы не возвращаться.
    
    return  is_can_exit_from_maze(maze, row - 1, col) || // Рекурсивно проверяем все 4 направления (вверх, вниз, влево, вправо).
            is_can_exit_from_maze(maze, row - 1, col) ||
            is_can_exit_from_maze(maze, row + 1, col) ||
            is_can_exit_from_maze(maze, row, col - 1) ||
            is_can_exit_from_maze(maze, row, col + 1);
}

int main(){
    int row, col, rows, cols;
    std::cin >> row >> col >> rows >> cols;
    std::cin.ignore(1); // Игнорируем перевод строки, застрявший в потоке ввода
    
    std::vector<std::string> maze(rows);
    for(auto& line : maze) std::getline(std::cin, line);
    
    std::cout << (is_can_exit_from_maze(maze, row, col) ? "YES" : "NO") << std::endl;
}
```
