# Контест №2. Функции и Массивы

## <ins>**Темы для решения контеста №2:**<ins/>

>• Фукнции: [SimpleCode - урок "Функции".](https://youtu.be/HFH65-sNQmI);
>
>• Динамический массив: [SimpleCode - урок "Динамический массив"](https://youtu.be/fk4YTLsnKmw);
>
>• Динамический массив <vector>: [Канал какого-то студента - урок "Вектор"](https://youtu.be/QOik-wo_uQE);

# C++

**1. Функция. Простое число.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.

bool is_prime(int n) { // Объявляем функцию is_prime, которая проверяет, является ли число простым.
    if (n < 2) return false; // Проверяем, меньше ли число 2. 
    if (n == 2) return true; // Проверяем, равно ли число 2.
    if (n % 2 == 0) return false; // Проверяем, делится ли число на 2 без остатка.
    
    for (int i = 3; i <= n / i; i += 2) { // Запускаем цикл для проверки делителей числа n.
        if (n % i == 0) return false; // Проверяем, делится ли n на текущий делитель i без остатка.
    }
    return true; // Возвращаем true, если цикл завершился без нахождения делителей.
}

int main(){ // Объявляем главную функцию программы, с которой начинается выполнение.
    int number; // Объявляем переменную number типа int для хранения введённого числа.
    std::cin >> number; // Считываем целое число и сохраняем его в переменную number.
    std::cout << (is_prime(number) ? "YES" : "NO") << std::endl;  // Выводим результат проверки числа, простое ли оно.
}
```

**2. Функция. Выход из лабиринта.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <vector> // Подключаем библиотеку для работы с динамическими массивами (std::vector).
#include <string> // Подключаем библиотеку для работы со строками (std::string).

bool is_can_exit_from_maze(std::vector<std::string>& maze, int row, int col) // Объявляем рекурсивную функцию, проверяющую, можно ли выйти из лабиринта из заданной точки.
{                                                 // maze - ссылка на вектор строк, представляющий лабиринт.
                                                  // row - текущая строка (координата Y) и col — текущий столбец (координата X).
    if (maze[row][col] =='#' || maze[row][col] =='.') return false; // Проверяем, является ли текущая клетка стеной ('#') или уже пройденной ('.'). Если да - возвращаем false (дальше идти нельзя).
    if (maze[row][col] == 'E') return true; // Если текущая клетка - выход ('E'), возвращаем true (цель достигнута).
    
    maze[row][col]='.'; // Помечаем текущую клетку как пройденную (заменяем символ на '.'), дабы не возвращаться.
    
    return  is_can_exit_from_maze(maze, row - 1, col) || // Рекурсивно проверяем все 4 направления (вверх, вниз, влево, вправо).
            is_can_exit_from_maze(maze, row - 1, col) || // Лишняя строка рекурсии :)
            is_can_exit_from_maze(maze, row + 1, col) ||
            is_can_exit_from_maze(maze, row, col - 1) ||
            is_can_exit_from_maze(maze, row, col + 1);
}

int main(){ // Объявляем главную функцию программы, с которой начинается выполнение.
    int row, col, rows, cols; // Объявляем переменные: row, col — начальные координаты (откуда начинаем поиск). rows, cols — размеры лабиринта (количество строк и столбцов).
    std::cin >> row >> col >> rows >> cols;
    std::cin.ignore(1); // После считывания чисел в потоке остаётся символ перевода строки (\n). Игнорируем (\n) чтобы следующий getline работал корректно.
    
    std::vector<std::string> maze(rows); // Создаём вектор строк maze размером rows.
    for(auto& line : maze) std::getline(std::cin, line); // В цикле считываем каждую строку лабиринта с помощью getline (читает строки с пробелами).
                                                         // auto& line — ссылка на элемент вектора, чтобы не копировать строку.
    std::cout << (is_can_exit_from_maze(maze, row, col) ? "YES" : "NO") << std::endl; // Вызываем функцию поиска выхода из начальной точки.
}
```

**4. Функция. Сортировка по количеству единиц.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <algorithm> // Подключаем библиотеку с готовыми алгоритмами (например, сортировка, подсчёт элементов).
#include <vector> // Подключаем библиотеку для работы с динамическими массивами (std::vector).
#include <string> // Подключаем библиотеку для работы со строками (std::string).

int count_ones(const std::string& num) { // Объявляем функцию count_ones, которая считает единицы в строке. const std::string& num — константная ссылка на строку.
    return std::count(num.begin(), num.end(), '1'); // Считаем, сколько раз символ '1' встречается в строке num.
}

bool compare(const std::string& a, const std::string& b) { // Объявляем функцию compare для сравнения двух строк (нужна для сортировки).
    int ones_a = count_ones(a); // Считаем единицы в строке a и сохраняем в переменную ones_a.
    int ones_b = count_ones(b); // Считаем единицы в строке b и сохраняем в переменную ones_b.

    if (ones_a != ones_b) // Если количество единиц в a и b разное, возвращаем true.
        return ones_a > ones_b; // Если в a единиц больше (тогда a будет раньше в сортировке).

    if (a.size() != b.size()) // Если единиц поровну, проверяем длины строк: если длины разные, возвращаем true.
        return a.size() < b.size(); // Если a короче (короткая строка идёт раньше).
    return a < b;
}

int main(){ // Объявляем главную функцию программы, с которой начинается выполнение.
    int count; // Создаём переменную count для хранения числа строк.
    std::cin >> count; // Считываем число строк от пользователя.
    
    std::vector<std::string> nums(count); // Создаём вектор nums из count строк.
    for(auto& line : nums) std::cin >> line; // Цикл: для каждой строки в векторе nums считываем её с ввода.
                                             // auto& line — автоматически определяет тип (std::string&).
                                             // std::cin >> line — читаем строку.
    std::sort(nums.begin(), nums.end(), compare); // Сортируем вектор nums:
                                                  // nums.begin() — начало вектора.
                                                  // nums.end() — конец вектора.
                                                  // compare — функция для сравнивнения строки.
    
    for(auto& line : nums) std::cout << line << ' '; // Цикл: выводим каждую строку из отсортированного вектора через пробел.
                                                     // std::cout << line — печатаем строку.
                                                     // << ' ' — добавляем пробел.
}
```

**5. Функция. Сумма дробей.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <tuple> // Подключаем библиотеку для работы с std::tuple (кортежами — структурами, хранящими несколько значений разных типов).

// Функция nod — нахождение НОД (наибольшего общего делителя)
int nod( int a, int b) { // Функция принимает два целых числа a и b.
    a=std::abs(a); // std::abs(a) — берёт модуль числа (делает его положительным). Это нужно, чтобы алгоритм работал с отрицательными числами.
    b=std::abs(b); // std::abs(b) — берёт модуль числа.
    while (b!=0) { // Цикл while работает, пока b не равно нулю.
        int nd=b; // Сохраняем текущее значение b во временную переменную.
        b=a%b; // Вычисляем остаток от деления a на b и записываем в b.
        a=nd; // Присваиваем a старое значение b.

// На каждой итерации пара чисел (a, b) уменьшается, но их НОД остаётся тем же. Когда b становится нулём, a содержит НОД.

    }
    return a; // Возвращаем a — это и есть НОД исходных чисел.
}

// Функция reduce — сокращение дроби.
std::pair <int,int> reduce(int x,  int y) { // Принимает числитель x и знаменатель y дроби. Возвращает std::pair<int, int> — пару целых чисел (сокращённую дробь).
    int i=nod(x,y); // Находим НОД числителя и знаменателя.
    x/=i; // Делим числитель на их НОД — дробь сокращается.
    y/=i; // Делим знаменатель на их НОД — дробь сокращается.
    if (y<0) { // Если знаменатель отрицательный, меняем знаки у числителя и знаменателя (по математическим правилам знак дроби принято писать в числителе).
        x=-x;
        y=-y;
    }
    return {x, y}; // Возвращаем сокращённую дробь как пару (числитель, знаменатель).
}

// Функция find_lcm — нахождение НОК (наименьшего общего кратного) и коэффициентов.
std:: tuple<int,int,int> find_lcm(int a,int b) { // Принимает два числа a и b. Возвращает кортеж из трёх целых чисел: НОК и два коэффициента.
    int g=nod(a,b); // Находим НОД чисел a и b.
    int lcm=a/g*b; // Вычисляем НОК по формуле: НОК(a, b) = (a * b) / НОД(a, b). Деление a / g делается первым, чтобы уменьшить риск переполнения.
    int c=lcm/a; // Во сколько раз НОК больше a (коэффициент для первой дроби).
    int d=lcm/b; // Во сколько раз НОК больше b (коэффициент для второй дроби).
    return {lcm,c,d}; // Возвращаем кортеж: (НОК, коэффициент для a, коэффициент для b).
}

int main() { // Объявляем главную функцию программы, с которой начинается выполнение.
    int m1, n1, m2, n2; // Числитель и знаменатель первой и второй дроби.
    char _; // Символ-разделитель (для чтения знака /).
    std::cin >> m1 >> _ >> n1 // Читаем ввод в формате: числитель1/знаменатель1,
             >> m2 >> _ >> n2; // Числитель2/знаменатель2.
    std::tie(m1, n1) = reduce(m1, n1); // Сокращаем обе дроби с помощью функции reduce. std::tie распаковывает пару, возвращённую reduce, в переменные m1, n1 и m2, n2.
    std::tie(m2, n2) = reduce(m2, n2);

    auto[lcm, c1, c2] = find_lcm(n1, n2); // Находим НОК знаменателей n1 и n2. Распаковываем результат в переменные:
                                          // lcm — общий знаменатель.
                                          // c1 — коэффициент для первой дроби.
                                          // c2 — коэффициент для второй дроби.

    auto[m, n] = reduce(m1 * c1 + m2 * c2, lcm); // Складываем дроби:
                                                 // m1 * c1 — числитель первой дроби после приведения к общему знаменателю.
                                                 // m2 * c2 — числитель второй дроби после приведения к общему знаменателю.
                                                 // m1 * c1 + m2 * c2 — сумма числителей.
                                                 // lcm — общий знаменатель.
                                                 // Сокращаем полученную дробь с помощью reduce. Распаковываем результат в m (числитель) и n (знаменатель).

    std::cout << m << '/' << n << std::endl; // Выводим результат в формате числитель/знаменатель.
}
```
