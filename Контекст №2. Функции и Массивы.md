# Контест №2. Функции и Массивы

## <ins>**Темы для решения контеста №2:**<ins/>

>• Фукнции: [SimpleCode - урок "Функции".](https://youtu.be/HFH65-sNQmI);
>
>• Динамический массив: [SimpleCode - урок "Динамический массив"](https://youtu.be/fk4YTLsnKmw);
>
>• Динамический массив (Vector): [Канал какого-то студента - урок "Вектор"](https://youtu.be/QOik-wo_uQE);

# C++

**1. Функция. Простое число.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.

bool is_prime(int n) { // Объявляем функцию is_prime, которая проверяет, является ли число простым.
    if (n < 2) return false; // Проверяем, меньше ли число 2. 
    if (n == 2) return true; // Проверяем, равно ли число 2.
    if (n % 2 == 0) return false; // Проверяем, делится ли число на 2 без остатка.
    
    for (int i = 3; i <= n / i; i += 2) { // Запускаем цикл для проверки делителей числа n.
        if (n % i == 0) return false; // Проверяем, делится ли n на текущий делитель i без остатка.
    }
    return true; // Возвращаем true, если цикл завершился без нахождения делителей.
}

int main(){ // Объявляем главную функцию программы, с которой начинается выполнение.
    int number; // Объявляем переменную number типа int для хранения введённого числа.
    std::cin >> number; // Считываем целое число и сохраняем его в переменную number.
    std::cout << (is_prime(number) ? "YES" : "NO") << std::endl;  // Выводим результат проверки числа, простое ли оно.
}
```

**2. Функция. Выход из лабиринта.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <vector> // Подключаем библиотеку для работы с динамическими массивами (std::vector).
#include <string> // Подключаем библиотеку для работы со строками (std::string).

bool is_can_exit_from_maze(std::vector<std::string>& maze, int row, int col) // Объявляем рекурсивную функцию, проверяющую, можно ли выйти из лабиринта из заданной точки.
{                                                 // maze - ссылка на вектор строк, представляющий лабиринт.
                                                  // row - текущая строка (координата Y) и col — текущий столбец (координата X).
    if (maze[row][col] =='#' || maze[row][col] =='.') return false; // Проверяем, является ли текущая клетка стеной ('#') или уже пройденной ('.'). Если да - возвращаем false (дальше идти нельзя).
    if (maze[row][col] == 'E') return true; // Если текущая клетка - выход ('E'), возвращаем true (цель достигнута).
    
    maze[row][col]='.'; // Помечаем текущую клетку как пройденную (заменяем символ на '.'), дабы не возвращаться.
    
    return  is_can_exit_from_maze(maze, row - 1, col) || // Рекурсивно проверяем все 4 направления (вверх, вниз, влево, вправо).
            is_can_exit_from_maze(maze, row - 1, col) || // Лишняя строка рекурсии :)
            is_can_exit_from_maze(maze, row + 1, col) ||
            is_can_exit_from_maze(maze, row, col - 1) ||
            is_can_exit_from_maze(maze, row, col + 1);
}

int main(){ // Объявляем главную функцию программы, с которой начинается выполнение.
    int row, col, rows, cols; // Объявляем переменные: row, col — начальные координаты (откуда начинаем поиск). rows, cols — размеры лабиринта (количество строк и столбцов).
    std::cin >> row >> col >> rows >> cols;
    std::cin.ignore(1); // После считывания чисел в потоке остаётся символ перевода строки (\n). Игнорируем (\n) чтобы следующий getline работал корректно.
    
    std::vector<std::string> maze(rows); // Создаём вектор строк maze размером rows.
    for(auto& line : maze) std::getline(std::cin, line); // В цикле считываем каждую строку лабиринта с помощью getline (читает строки с пробелами).
                                                         // auto& line — ссылка на элемент вектора, чтобы не копировать строку.
    std::cout << (is_can_exit_from_maze(maze, row, col) ? "YES" : "NO") << std::endl; // Вызываем функцию поиска выхода из начальной точки.
}
```

**4. Функция. Сортировка по количеству единиц.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <algorithm> // Подключаем библиотеку с готовыми алгоритмами (например, сортировка, подсчёт элементов).
#include <vector> // Подключаем библиотеку для работы с динамическими массивами (std::vector).
#include <string> // Подключаем библиотеку для работы со строками (std::string).

int count_ones(const std::string& num) { // Объявляем функцию count_ones, которая считает единицы в строке. const std::string& num — константная ссылка на строку.
    return std::count(num.begin(), num.end(), '1'); // Считаем, сколько раз символ '1' встречается в строке num.
}

bool compare(const std::string& a, const std::string& b) { // Объявляем функцию compare для сравнения двух строк (нужна для сортировки).
    int ones_a = count_ones(a); // Считаем единицы в строке a и сохраняем в переменную ones_a.
    int ones_b = count_ones(b); // Считаем единицы в строке b и сохраняем в переменную ones_b.

    if (ones_a != ones_b) // Если количество единиц в a и b разное, возвращаем true.
        return ones_a > ones_b; // Если в a единиц больше (тогда a будет раньше в сортировке).

    if (a.size() != b.size()) // Если единиц поровну, проверяем длины строк: если длины разные, возвращаем true.
        return a.size() < b.size(); // Если a короче (короткая строка идёт раньше).
    return a < b;
}

int main(){ // Объявляем главную функцию программы, с которой начинается выполнение.
    int count; // Создаём переменную count для хранения числа строк.
    std::cin >> count; // Считываем число строк от пользователя.
    
    std::vector<std::string> nums(count); // Создаём вектор nums из count строк.
    for(auto& line : nums) std::cin >> line; // Цикл: для каждой строки в векторе nums считываем её с ввода.
                                             // auto& line — автоматически определяет тип (std::string&).
                                             // std::cin >> line — читаем строку.
    std::sort(nums.begin(), nums.end(), compare); // Сортируем вектор nums:
                                                  // nums.begin() — начало вектора.
                                                  // nums.end() — конец вектора.
                                                  // compare — функция для сравнивнения строки.
    
    for(auto& line : nums) std::cout << line << ' '; // Цикл: выводим каждую строку из отсортированного вектора через пробел.
                                                     // std::cout << line — печатаем строку.
                                                     // << ' ' — добавляем пробел.
}
```

**5. Функция. Сумма дробей.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <tuple> // Подключаем библиотеку для работы с std::tuple (кортежами — структурами, хранящими несколько значений разных типов).

// Функция nod — нахождение НОД (наибольшего общего делителя)
int nod( int a, int b) { // Функция принимает два целых числа a и b.
    a=std::abs(a); // std::abs(a) — берёт модуль числа (делает его положительным). Это нужно, чтобы алгоритм работал с отрицательными числами.
    b=std::abs(b); // std::abs(b) — берёт модуль числа.
    while (b!=0) { // Цикл while работает, пока b не равно нулю.
        int nd=b; // Сохраняем текущее значение b во временную переменную.
        b=a%b; // Вычисляем остаток от деления a на b и записываем в b.
        a=nd; // Присваиваем a старое значение b.

// На каждой итерации пара чисел (a, b) уменьшается, но их НОД остаётся тем же. Когда b становится нулём, a содержит НОД.

    }
    return a; // Возвращаем a — это и есть НОД исходных чисел.
}

// Функция reduce — сокращение дроби.
std::pair <int,int> reduce(int x,  int y) { // Принимает числитель x и знаменатель y дроби. Возвращает std::pair<int, int> — пару целых чисел (сокращённую дробь).
    int i=nod(x,y); // Находим НОД числителя и знаменателя.
    x/=i; // Делим числитель на их НОД — дробь сокращается.
    y/=i; // Делим знаменатель на их НОД — дробь сокращается.
    if (y<0) { // Если знаменатель отрицательный, меняем знаки у числителя и знаменателя (по математическим правилам знак дроби принято писать в числителе).
        x=-x;
        y=-y;
    }
    return {x, y}; // Возвращаем сокращённую дробь как пару (числитель, знаменатель).
}

// Функция find_lcm — нахождение НОК (наименьшего общего кратного) и коэффициентов.
std:: tuple<int,int,int> find_lcm(int a,int b) { // Принимает два числа a и b. Возвращает кортеж из трёх целых чисел: НОК и два коэффициента.
    int g=nod(a,b); // Находим НОД чисел a и b.
    int lcm=a/g*b; // Вычисляем НОК по формуле: НОК(a, b) = (a * b) / НОД(a, b). Деление a / g делается первым, чтобы уменьшить риск переполнения.
    int c=lcm/a; // Во сколько раз НОК больше a (коэффициент для первой дроби).
    int d=lcm/b; // Во сколько раз НОК больше b (коэффициент для второй дроби).
    return {lcm,c,d}; // Возвращаем кортеж: (НОК, коэффициент для a, коэффициент для b).
}

int main() { // Объявляем главную функцию программы, с которой начинается выполнение.
    int m1, n1, m2, n2; // Числитель и знаменатель первой и второй дроби.
    char _; // Символ-разделитель (для чтения знака /).
    std::cin >> m1 >> _ >> n1 // Читаем ввод в формате: числитель1/знаменатель1,
             >> m2 >> _ >> n2; // Числитель2/знаменатель2.
    std::tie(m1, n1) = reduce(m1, n1); // Сокращаем обе дроби с помощью функции reduce. std::tie распаковывает пару, возвращённую reduce, в переменные m1, n1 и m2, n2.
    std::tie(m2, n2) = reduce(m2, n2);

    auto[lcm, c1, c2] = find_lcm(n1, n2); // Находим НОК знаменателей n1 и n2. Распаковываем результат в переменные:
                                          // lcm — общий знаменатель.
                                          // c1 — коэффициент для первой дроби.
                                          // c2 — коэффициент для второй дроби.

    auto[m, n] = reduce(m1 * c1 + m2 * c2, lcm); // Складываем дроби:
                                                 // m1 * c1 — числитель первой дроби после приведения к общему знаменателю.
                                                 // m2 * c2 — числитель второй дроби после приведения к общему знаменателю.
                                                 // m1 * c1 + m2 * c2 — сумма числителей.
                                                 // lcm — общий знаменатель.
                                                 // Сокращаем полученную дробь с помощью reduce. Распаковываем результат в m (числитель) и n (знаменатель).

    std::cout << m << '/' << n << std::endl; // Выводим результат в формате числитель/знаменатель.
}
```

# Golang

**6. Функция. Палиндром с игнорированием.**

```go
package main // Строка начала исполняемой программы.

import ( // Подключаем библиотеки.
	"bufio" // Для буферизованного ввода/вывода (удобно читать строки из консоли).
	"fmt" // Для форматированного вывода (например, fmt.Println).
	"os" // Для работы с операционной системой (в нашем случае — чтение из стандартного ввода).
	"strings" // Для манипуляций со строками (преобразование регистра, замена символов и т. д.).
)

// Объявляем функцию оторая проверяет, является ли строка палиндромом (читается одинаково слева направо и справа налево).
func isPalindrome(str string) bool { // Объявляем функцию isPalindrome. Она принимает один параметр str типа string (строка). Возвращает true / false.
	str = strings.ToLower(str) // Преобразуем всю строку в нижний регистр.
	str = strings.Replace(str, "~", "", -1) // Последовательно удаляем из строки разные знаки препинания и пробелы.
	str = strings.Replace(str, "!", "", -1) // strings.Replace(строка, что_заменять, на_что_заменять, количество_замен).
	str = strings.Replace(str, "@", "", -1) // -1 означает «заменить все вхождения». 
	str = strings.Replace(str, "#", "", -1)
	str = strings.Replace(str, "%", "", -1)
	str = strings.Replace(str, "^", "", -1)
	str = strings.Replace(str, "&", "", -1)
	str = strings.Replace(str, "*", "", -1)
	str = strings.Replace(str, "(", "", -1)
	str = strings.Replace(str, ")", "", -1)
	str = strings.Replace(str, " ", "", -1)
	if len(str) == 0 { // Проверяем длину строки после очистки.
		return true // Если строка стала пустой, считаем её палиндромом (true).
	}
	out := true // Хранит результат проверки. Изначально считаем, что строка — палиндром.
	for i := 0; i < len(str)/2; i++ { // Цикл идёт до len(str)/2 (половина длины строки). Мы сравниваем первый символ с последним, второй — с предпоследним и т. д.
		if str[i] != str[len(str)-1-i] { // Сравниваем символ на позиции i с символом на позиции len(str)-1-i
                                         // len(str)-1 — индекс последнего символа (так как индексация с 0).
                                         // len(str)-1-i — симметричный символ с конца.
                                         // Если символы не совпадают, устанавливаем out = false (строка не палиндром).
		}
	}
	return out // Возвращаем значение out (true или false). true - палиндром / false - не  палиндром.
}

func main() { // Объявляем главную функцию программы, с которой начинается выполнение.
	line, _ := bufio.NewReader(os.Stdin).ReadString('\n') // Читаем строку из стандартного ввода (консоли).
                                                          // bufio.NewReader(os.Stdin) — создаём буферизованный ридер для стандартного ввода.
                                                          // .ReadString('\n') — читаем до символа перевода строки (\n).
                                                          // Результат: строка line и ошибка (мы её игнорируем, используя _).
                                                          // В line окажется введённая пользователем строка вместе с символом \n в конце.

	if isPalindrome(line[:len(line)-1]) { // Вызываем функцию isPalindrome, передавая ей обработанную строку.
                                          // line[:len(line)-1] — «срез» строки: берём все символы от начала до предпоследнего.
                                          // Зачем? Чтобы убрать символ \n в конце (он добавляется при вводе).

		fmt.Println("YES") // Палиндром.
	} else {
		fmt.Println("NO") // Не палиндром.
	}
}
```

**7. Функция. Счастливый билет.**
```go
package main // Строка начала исполняемой программы.
import ( // Подключаем библиотеки.
    "bufio" // Для буферизованного ввода/вывода (удобно читать строки из консоли).
    "fmt" // Для форматированного вывода (например, fmt.Println).
    "os" // Для работы с операционной системой (в нашем случае — чтение из стандартного ввода).
)

func isLucky( s string) bool{ // Объявляем функцию isLucky. Она принимает один аргумент: s типа string. Возвращает значение типа bool (true или false).
     return (int(s[0]) + int(s[1]) + int(s[2])) == // Функция проверяет, равна ли сумма первых трёх цифр строки сумме последних трёх цифр.
           (int(s[3]) + int(s[4]) + int(s[5])) // s[0], s[1], …, s[5] — это отдельные символы строки (по индексу: 0 — первый, 5 — шестой).
                                               // int(s[i]) преобразует символ в число.
}

func main() { // Объявляем главную функцию программы, с которой начинается выполнение. 
    number, _  := bufio.NewReader(os.Stdin).ReadString('\n') // bufio.NewReader(os.Stdin) создаёт буферизированный ридер для стандартного ввода (клавиатура).
                                                             // .ReadString('\n') читает строку до символа перевода строки (\n).
    if isLucky( number[:len(number)-1] ){  // Обрезаем \n в конце строки.
        fmt.Println("YES") // Номер счастливый.
    }else{
        fmt.Println("NO") // Номер не счастливый
    }
}
```
