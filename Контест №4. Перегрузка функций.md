# Контест №4. Перегрузка функций.

## <ins>**Темы для решения контеста №4:**<ins/>

# C++

**1. Функция. Площадь треугольника.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <cmath> // Подключаем математическую библиотеку.
#include <iomanip> // Подключаем библиотеку для форматирования вывода.

// Первая функция: вычисление площади по сторонам
double triangle_area(double a, double b, double c) { // Объявляем функцию с именем triangle_area.
                                                     // Возвращает значение типа double (число с плавающей точкой).
                                                     // Принимает 3 параметра типа double: длины сторон треугольника a, b, c.

    if (a + b <= c || a + c <= b || b + c <= a) // Проверяем, можно ли из данных сторон построить треугольник. По неравенству треугольника сумма любых двух сторон должна быть строго больше третьей.
        return -1;  // Если условие выполняется (<=), значит треугольник не существует — функция возвращает -1 как признак ошибки.
    double p = (a + b + c) / 2.0; // Вычисляем полупериметр треугольника (p).
    return sqrt(p * (p - a) * (p - b) * (p - c)); // Возвращаем площадь треугольника по формуле Герона:
}

// Вторая функция: вычисление площади по координатам
double triangle_area(double x1, double y1, double x2, double y2, double x3, double y3) { // Функция с тем же именем triangle_area (перегрузка функции). Принимает 6 параметров: координаты трёх вершин треугольника:
                                                                                         // (x1, y1) — первая точка,
                                                                                         // (x2, y2) — вторая точка,
                                                                                         // (x3, y3) — третья точка.

    double s = 0.5 * fabs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)); // Вычисляем площадь по формуле площади треугольника через координаты вершин:
                                                                             // Результат сохраняется в переменной s.
                                                                             // fabs() — модуль числа (из <cmath>), гарантирует положительный результат.

    return (s == 0 ? -1 : s); // Проверяем, равна ли площадь нулю.
                              // Если s == 0, значит точки лежат на одной прямой (треугольник не существует) — возвращается -1.
                              // Иначе возвращается вычисленная площадь s.
}

int main() // Объявляем главную функцию программы, с которой начинается выполнение.
{
    int type; // Объявляем переменную type типа int (целое число).
              // Это «флаг», который определяет, какой способ расчёта использовать:
              // 0 — по сторонам, другое значение — по координатам.
              
    std::cin >> type; // Считываем число с клавиатуры и сохраняет в type.
    
    double S; // Объявляем переменную S типа double для хранения результата (площади).
    if (type == 0){  // Проверяем, равно ли type нулю. Если да — выполняется блок в фигурных скобках:
        int a, b, c; // Объявляем три целочисленные переменные для сторон треугольника.
        std::cin >> a >> b >> c; // Считывает их с клавиатуры; 
        S = triangle_area(a, b, c); // Вызываем первую версию функции triangle_area (по сторонам).
    }else{ // Если type не равен нулю — выполняется этот блок.
        int x1, y1, x2, y2, x3, y3; // Объявляем 6 целочисленных переменных для координат вершин.
        std::cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3; // Считываем их с клавиатуры.
        S = triangle_area(x1, y1, x2, y2, x3, y3); // Вызываем вторую версию функции triangle_area (по координатам). Результат сохраняется в S.
    }
    
    std::cout << std::setprecision(5) << S; // Выводим результат на экран.
                                            // std::setprecision(5) — устанавливает точность вывода чисел в 5 значащих цифр.
                                            // Если S = -1, выведется -1 (ошибка: треугольник не существует).
                                            // Если S > 0, выведется площадь с точностью до 5 знаков.
}
```

**3. Функция. Булевый форматер.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <string> // Подключаем библиотеку для работы со строками (std::string).
using namespace std; // Используем пространства имён.

template <typename T> // Начинаем объявление шаблонной функции.
                      // T — это параметр-тип, который будет подставляться при вызове функции.
                      // То есть функция сможет работать с любым типом данных (int, double, string и др.).

T formatter(T value) { // Объявляем шаблонную функцию formatter, которая:
                       // Принимаем один параметр value типа T;
                       // Возвращаем значение типа T;
                       // Просто возвращает переданный аргумент без изменений.

	return value; // Возвращаем переданный аргумент value «как есть». Например, если передали 5, вернётся 5;
}

string formatter(bool value) { // Объявляем перегруженную функцию formatter специально для типа bool. Эта версия:
                               // Принимает параметр value типа bool (true/false);
                               // Возвращает std::string (строку);
                               // Преобразует true в строку "true", а false — в "false".

	return  value ?"true": "false"; // Используем условный оператор (?:):
                                  // Если value == true, возвращает строку "true";
                                  // Если value == false, возвращает строку "false".
}

int main() // Объявляем главную функцию программы, с которой начинается выполнение.
{
    int n; // Объявляем переменную n типа int (целое число).
    std::cin >> n; // Считываем целое число с клавиатуры и сохраняет его в переменную n.

    std::cout << formatter(n) << ' ' // Вызывается шаблонная версия formatter, которая просто возвращает n. Пробел ' ' после значения.
              << formatter(1.5*n) <<  ' ' // Вычисляет 1.5 * n. Вызывает formatter(). Выводит пробел после значения.
              << formatter(static_cast<bool>(n)) <<  ' ' // static_cast<bool>(n) преобразует n в bool: если n != 0, результат true; если n == 0, результат false;
                                                         // Вызывает formatter(true) или formatter(false): тут срабатывает перегруженная версия для bool (строки 8–10), которая вернёт строку "true" или "false";
                                                         // Выводит пробел после строки.

              << formatter("\"" + std::to_string(n) + "\""); // std::to_string(n) преобразует число n в строку (например, 42 → "42");
                                                             // "\"" + ... + "\"" добавляет кавычки по краям: получается строка вроде "42";
                                                             // вызывает formatter("\"42\""): так как аргумент — строка (std::string), срабатывает шаблонная версия, возвращающая эту строку без изменений;
                                                             // выводит строку с кавычками (например, "42").
```

**4. Функция. Сумма элементов.**
```cpp
#include <iostream> // Подключаем стандартную библиотеку ввода‑вывода C++.
#include <string> // Подключаем библиотеку для работы со строками (std::string).
#include <vector> // Подключаем библиотеку для работы с динамическими массивами (std::vector).
using namespace std; // Используем пространства имён.

template <typename T> // Начинаем объявление шаблонной функции.
T sum(const vector <T>& vec) { // Объявляем функцию sum, которая:
							   // Принимает один аргумент — константную ссылку на вектор типа vector<T> (то есть вектор элементов типа T);
							   // Возвращает значение типа T.
							   // const означает, что функция не изменит исходный вектор.
							   // & означает передачу по ссылке (экономит память, не копирует вектор).

	T result = T(); // Создаём переменную result типа T. T() — это инициализация по умолчанию для типа T:
					// для int это 0;
						// для double это 0.0;
						// для string это пустая строка "".
	
		for (const auto& item : vec) { // Цикл for с диапазоном (range‑based for). Перебирает все элементы вектора vec. const auto& означает:
									   // auto — тип item определяется автоматически (такой же, как у элементов вектора);
									   // const — элемент не будет изменён;
									   // & — передаём элемент по ссылке (без копирования).
		
			result += item; // Добавляем текущий элемент item к переменной result. Оператор += должен быть определён для типа T (для int, double, string он есть).
		}
	return result; // Закрываем цикл и возвращаем накопленную сумму result.
}

int main() // Объявляем главную функцию программы, с которой начинается выполнение.
{
    int n; // Объявляем переменную n типа int (целое число).
    std::cin >> n; // Считываем число с клавиатуры и сохраняем в n.
    
    std::vector<int> vi(n); // vi — вектор целых чисел (int) размером n.
    std::vector<double> vd(n); // vd — вектор чисел с плавающей точкой (double) размером n.
    std::vector<std::string> vs(n); // vs — вектор строк (std::string) размером n.
								    // Все элементы векторов изначально инициализированы значениями по умолчанию (0, 0.0, “”).
									
    for (int i=0; i<n; i++){ // Цикл for, который выполнится n раз. i — счётчик от 0 до n-1.
        int item; // Объявляем переменную item типа int;
        std::cin >> item; // Считываем целое число с клавиатуры и сохраняем в item.
        vi[i] = item; // Записываем считанное число item в i-й элемент вектора vi.
        vd[i] = item*1.5; // Вычисляем item * 1.5 (число с плавающей точкой) и записываем в i-й элемент вектора vd.
        vs[i] = std::to_string(item); // Преобразуем число item в строку с помощью std::to_string(). Записываем полученную строку в i-й элемент вектора vs.
    }
    
    std::cout << sum(vi) << '\n' // sum(vi) — сумма всех элементов вектора vi (целые числа).
              << sum(vd) << '\n' // sum(vd) — сумма всех элементов вектора vd (числа с плавающей точкой).
              << sum(vs); // sum(vs) — конкатенация (склеивание) всех строк из вектора vs.
}
```

# Golang

**6. Дженерики. Sum**
```Go
package main // Строка начала исполняемой программы.
import "fmt" // Подключаем библиотеку для форматированного вывода (например, fmt.Println).

func sum(items interface{}) interface{} { // Объявляем функцию sum с двумя параметрами-загадками:
										  // Вход: items типа interface{} (любой тип).
										  // Выход: тоже interface{} (может вернуть любой тип).
										  // функция должна уметь работать и с числами, и со строками — поэтому использует «универсальный» тип interface{}.
										  
    switch v := items.(type) { // Начинаем конструкцию switch для типизации интерфейса.
							   // items.(type) — «вытаскивает» реальный тип переменной items.
	 						   // v — новая переменная, которая получит значение items, уже «приведённое» к его реальному типу.
							   // Дальше мы будем обрабатывать разные типы по‑разному.
	
    case[]int: // Если items оказался срезом целых чисел ([]int), выполняем этот блок.
    total := 0 // Создаём переменную total типа int со значением 0. Будем накапливать сумму чисел.
    for _, num := range v { // Цикл по всем элементам среза v.
							// _ — игнорируем индекс элемента (нам он не нужен).
							// num — текущая числовая переменная из среза.

        total+=num // Прибавляем num к total.
    }
        return total // Возвращаем сумму чисел (total) из функции.
    case []string: // Если items — срез строк ([]string), выполняем этот блок.
        result:="" // Создаёт пустую строку result.
        for _,str := range v { // Цикл по всем строкам среза v.
							   // _ — игнорируем индекс
							   // str — текущая строка.
            result+=str // Добавляем str к result.
        }
        return result // Возвращаем «склеенную» строку.
    }
     return 0 // Если тип items не []int и не []string, возвращает 0.
}

func main() { // Объявляем главную функцию программы, с которой начинается выполнение. 
    var n int // Создаём переменную n типа int (целое число).
    fmt.Scan(&n) // Cчитываем число с клавиатуры и записывает его в n. 
				 // &n — передаёт «адрес» переменной n (чтобы Scan мог её изменить).
    
    nums := make([]int, n) // Создаём срез целых чисел длиной n.
    strings := make([]string, n) // Создаём срез строк длиной n.
    
    for i := range nums { // Цикл по индексам среза nums. i — текущий индекс (0, 1, 2, …, n-1).
        fmt.Scan(&nums[i]) // Считываем число и записывает его в nums[i].
        strings[i] = fmt.Sprint(nums[i]) // Преобразуем число nums[i] в строку и кладёт в strings[i].
										 // fmt.Sprint — функция, которая «печатает» значение в виде строки.
    }
    
    fmt.Println(sum(nums)) // Вызываем sum(nums) — передаёт срез чисел nums в функцию sum.
						   // sum вернёт сумму чисел (тип int, но «завёрнутый» в interface{}).
						   // fmt.Println печатает результат.

    fmt.Println(sum(strings)) // Вызываем sum(strings) — передаёт срез строк strings в sum.
							  // sum «склеит» строки и вернёт результат (тип string, «завёрнутый» в interface{}).
							  // fmt.Println печатает результат.
}
```

**7. Плохой пользователь.**
```Go
package main // Строка начала исполняемой программы.
import "fmt" // Подключаем библиотеку для форматированного вывода (например, fmt.Println).

func FindIndex[T comparable] (slice []T, target T) []int { // Объявляем функцию FindIndex с параметрическим полиморфизмом (дженерики).
														   // T comparable — тип T должен поддерживать операцию сравнения (==).
														   // Принимает:
														   // slice []T — срез (массив) элементов типа T;
														   // target T — значение, которое ищем.
														   // Возвращает: []int — срез индексов, где найдено совпадение.

    var indexes []int // Создаём пустую переменную indexes типа []int (срез целых чисел). Сюда будем складывать индексы найденных элементов.
    for i, v := range slice { // Цикл по всем элементам среза slice. i — индекс элемента. v — значение элемента.
        if v == target { // Если текущий элемент v равен искомому target — выполняем блок.
            indexes = append(indexes, i) // Добавляем индекс i в срез indexes с помощью функции append.
        }
    }
    return indexes // Возвращаем срез индексов, где был найден target.
}

func main(){ // Объявляем главную функцию программы, с которой начинается выполнение.
    var count int // Объявляем переменную count типа int (целое число). В неё запишем количество пользователей.
    fmt.Scan(&count) // Считываем число с ввода и сохраняем в count. &count — передача адреса переменной (чтобы Scan мог её изменить).

    status  := make([]string, count) // Создаём срез status типа []string (массив строк) длиной count. make — встроенная функция для создания срезов, карт и каналов.
    for i:=0; i<count; i++ { // Цикл от 0 до count-1. i — индекс пользователя.
        fmt.Scan(&status[i]) // Считываем одну строку с входного потока. Сохраняем прочитанную строку в элемент среза status с индексом i. На каждой итерации цикла заполняется один элемент:
							 // на первой итерации (i = 0) — status[0];
							 // на второй (i = 1) — status[1];
							 // и так до status[count − 1].

    }

    balance := make([]int, count) // Создаём новый срез (массив) balance типа []int (список целых чисел).
								  // Длина среза — count (столько же, сколько пользователей).
								  // Все элементы изначально равны 0 (нулевое значение для int).
								  
    for i:=0; i<count; i++ {  // Запускаем ещё один цикл от 0 до count − 1. Цель: заполнить срез balance значениями балансов пользователей.
        fmt.Scan(&balance[i]) // Считываем одно целое число с входного потока. Сохраняем его в элемент balance[i]. На каждой итерации заполняется один элемент:
    }    

    badUserIndex := FindIndex(status, "blocked") // Вызываем функцию FindIndex, чтобы найти все индексы, где в срезе status встречается строка "blocked".
    badUserIndex = append(badUserIndex, FindIndex(balance, 0)...) // Расширяем список badUserIndex, добавляя в него индексы, где в balance стоит 0. Как это работает:
																  // FindIndex(balance, 0) — ищет все индексы, где баланс равен 0, возвращает срез (например, [1]).
																  // ... — «распаковывает» срез, чтобы append добавил каждый элемент отдельно.
																  // append(badUserIndex, ...) — добавляет новые индексы к существующему списку badUserIndex.
																  
    uniqueIndexes := make(map[int]bool) // Создаём карту (словарь) uniqueIndexes:
										// Ключи — целые числа (int) — это индексы пользователей.
										// Значения — булевы (bool) — просто флаг true (нас интересует только наличие ключа).
										// Цель: убрать дубликаты из badUserIndex (если один и тот же индекс встретился дважды, он будет учтён только один раз).
	
    for i:=0; i<len(badUserIndex); i++ { // Запускаем цикл по всем элементам среза badUserIndex.
										 // len(badUserIndex) — длина среза (сколько всего «подозрительных» индексов).
										 // i — счётчик от 0 до длины среза − 1.
										 
        uniqueIndexes[badUserIndex[i]] = true // На каждой итерации:
											  // Берём элемент badUserIndex[i] (это индекс пользователя, например, 1).
											  // Используем его как ключ в карте uniqueIndexes.
											  // Устанавливаем значение true (это значит: «такой индекс есть в списке»).
											  // Если индекс повторяется (например, 1 встречается дважды), он всё равно будет записан в карту только один раз (карты не допускают дубликатов ключей).
    }

    fmt.Println(len(uniqueIndexes)) // fmt.Println — выводит это число на экран.
									// len(uniqueIndexes) — количество ключей в карте (то есть количество уникальных индексов «плохих» пользователей).
}
```
